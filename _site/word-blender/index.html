<!doctype html>

<html>
  <head>
    <title>Word Blender</title>
    <link rel="stylesheet/less" href="/lib/bootstrap.less">
    <link rel="stylesheet" href="/css/vimgolfdigest.css">
    <script src="/js/less-1.1.5.min.js"></script>
  </head>
  <body>
    <div class="container">
      <div class="row">
  <header class="span4">
    <h1><a href="/">VimGolf Digest</a> <small>by Dan Dorman</small></h1>
  </header>

  <article class="span12">
    <h1 id='word_blender'>Word Blender</h1>

<p>One of the coolest things to pop up recently is <a href='http://vimgolf.com'>VimGolf</a>, in which participants compete to solve &#8220;challenges.&#8221; That is, they modify some given text to match specific target output in the fewest number of keystrokes&#8212;using the <a href='http://www.vim.org/'>Vim editor</a>, of course. I consider myself reasonably proficient with Vim; VimGolf is a humbling reminder of how much I still have to learn.</p>

<p>VimGolf&#8217;s best feature allows you to look at other solutions once you&#8217;ve submitted your own, which provides a trove of great ideas for shaving superfluous keystrokes from your editing. I quickly learned, for instance, that saving a file with <code>:wq</code> is a two-character waste compared to the much more svelte <code>ZZ</code>.</p>

<h2 id='the_challenge'>The Challenge</h2>

<p>The solution to one challenge, however, really blew my mind with all the nifty Vim awesomeness I picked up from analyzing it. The challenge is called <a href='http://vimgolf.com/challenges/4d2482950947c63e260000b1'>&#8220;Word Blender&#8221;</a> (submitted by VimGolf user <a href='http://vimgolf.com/gumnos'>Tim Chase</a>). The basic idea is that all of the words in the sample text have had their interiors reversed: for example, <em>talking</em> becomes <em>tniklag</em>. The first and last characters stay the same; only the characters in the middle have their positions moved&#8212;thus words of fewer than four characters remain the same. To solve the challenge, you need to fix all the thusly rearranged words.</p>

<h2 id='the_old_college_try'>The Old College Try</h2>

<p>My own <a href='http://vimgolf.com/challenges/4d2482950947c63e260000b1#4d24f6420947c63e26000181'>solution</a> is fairly pedestrian, a simple global search-and-replace:</p>

<p><code>:%s/\v(\w)(\w+)(\w)/\=submatch(1).join(reverse(split(submatch(2),&#39;\zs&#39;)),&#39;&#39;).submatch(3)/gZZ</code></p>

<p>At 93 characters, it&#8217;s nowhere near the best (at the time of this writing, a mind-boggling <em>30</em> keystrokes), but I still had to dig through Vim&#8217;s expansive help to come up with it. I&#8217;d never used the <code>\=</code> construct in a replace command before, so all the function calls in there were fresh Vim learning.</p>

<p>The <code>\v</code>, at the beginning of the search regular expression, was another thing I&#8217;ve picked up since taking up VimGolf. By default, Vim requires that a lot of the &#8220;magic&#8221; characters in regular expressions be escaped (generally, those with anything beyond their literal interpretations, like parens or pipes). The <code>\v</code> flag triggers &#8220;very magic&#8221; mode, relaxing the escaping rules. So in my solution, that saved a net of four characters, since each of the parens in <code>(\w)(\w+)(\w)</code> would have required a backlash prefix! (Beyond padding a VimGolf score, this is useful for making complex regular expressions more readable.)</p>

<h2 id='awesome_sauce'>Awesome Sauce</h2>

<p>The real inspiration for this blog post, however, is <a href='http://vimgolf.com/_matthewd'>Matthew Draper</a>&#8217;s solution to the same challenge. Here it is in its entirety:</p>

<p><code>0qx&quot;RXq/\v&amp;lt;\w{4}qq&quot;rxlyee@=len(@&quot;)@x&quot;rPnq119@qZZ</code></p>

<p>Now I&#8217;ll break down what&#8217;s going on in this compact bundle of win:</p>

<ol>
<li><strong><code>0</code></strong>. Move to the first character of the line.</li>

<li><strong><code>qx</code></strong>. Start recording a macro, saving it in the <em>x</em> buffer.</li>

<li><strong><code>&quot;RX</code></strong>. <code>X</code> deletes the character to the <em>left</em> of the cursor; the <code>&quot;R</code> preceding it stuffs that deleted character into the <code>r</code> register.<br />And&#8212;extra nifty&#8212;the fact that it&#8217;s a <em>capital R</em> means it <em>appends</em> to the <code>r</code> register instead of just replacing its contents.</li>

<li><strong><code>q</code></strong>. Finish recording the <em>x</em> macro.</li>

<li><strong><code>/\v&amp;lt;\w{4}</code></strong>. Search for the next chunk of four word characters.<br />Remember, words of fewer than four characters don&#8217;t need to be changed. Note the use of <code>\v</code> to trigger &#8220;very magic&#8221; mode in the search expression. It actually doesn&#8217;t save anything (<code>/\&amp;lt;\w\{4}</code> is an equivalent search expression with the same number of characters), but it arguably looks cleaner.</li>

<li><strong><code>qq</code></strong>. Start recording a second macro, this one saved in the <em>q</em> buffer.</li>

<li><strong><code>&quot;rx</code></strong>. The <code>x</code> deletes the character the cursor is on; the <code>&quot;r</code> stuffs it into the <em>r</em> register. Thanks to the preceding search, we&#8217;re at the beginning of a target word, so we&#8217;ve just taken the first character of that word and deleted it and stuffed it into a register for later retrieval. Note that it&#8217;s a <em>lowercase r</em> this time, so the register&#8217;s contents are <em>replaced</em> with just that single letter. Later, this will effectively reset the <em>r</em> register when another word is visited.</li>

<li><strong><code>l</code></strong>. Move one character to the right.</li>

<li><strong><code>ye</code></strong>. Copy all the characters through the end of the word.</li>

<li><strong><code>e</code></strong>. Move to the end of the word.</li>

<li><strong><code>@=</code></strong>. <code>@</code> is normally used to execute a macro; for instance, <code>@x</code> would execute the macro recorded in steps 2&#8211;4. <code>@=</code> is a special case: You are moved to Vim&#8217;s command line, where you can enter an expression whose results will be executed. We&#8217;ll see the expression Matthew uses in the next step.</li>

<li><strong><code>len(@&quot;)</code></strong>. This is the expression (followed by the enter key) provided to the <code>@=</code> command initiated in the preceding step. It calls the len function on <code>@&quot;</code>. In the context of Vim&#8217;s command line, the <code>@</code> lets you access the contents of a register. The <code>&quot;</code> is a way to refer to the so-called unnamed register, which contains whatever was last yanked. The last thing we yanked was the current word, less two characters (we already chopped off the first letter (step 7), then moved one character to the right (step 8) before yanking rest of it (step 9). So the result of this expression is the length of the current word less two. You know how most commands in Vim can be prefaced with the number of times you&#8217;d like it to execute? These last two steps have set that up, dumping us back into normal mode as though we&#8217;d just typed that calculated length value in manually; Vim&#8217;s now waiting for us to tell it what command to execute that number of times. Marvelous!</li>

<li><strong><code>@x</code></strong>. Execute the macro stored in buffer <em>x</em>, recorded in steps 2&#8211;4, which deletes the character to the left of the cursor and <em>appends</em> it to the <em>r</em> register. Thanks to steps 11 and 12, we&#8217;re executing this macro a number of times equal to the length of the current word less two. We already moved to the last character of the word (step 10), so this effectively backspaces across the word, adding each character deleted to the buffer. Since these interior characters are in reverse order, the <em>r</em> register is being built up in the <em>correct</em> order. Ingenious!</li>

<li><strong><code>&quot;rP</code></strong>. As a result of step 13, there&#8217;s only one character left in the current word, its last letter&#8212;the rest has all been stashed in the <em>r</em> register. The <code>P</code> puts its source contents immediately <em>before</em> the cursor position; the <code>&quot;r</code> tells Vim that <em>what</em> we want to put is the contents of the <em>r</em> register: the rest of the current word, now all in correct order. Brilliant!</li>

<li><strong><code>n</code></strong>. Move to the next match to our search criteria (<code>\w{4}</code>, the next word of at least four characters).</li>

<li><strong><code>q</code></strong>. Stop recording the macro.</li>

<li><strong><code>119@q</code></strong>. Execute the macro recorded in the <em>q</em> buffer (steps 6 â€“ 16) 119 times. It goes through the rest of the sample text, fixing all the words that need it. It&#8217;s not as elegant as the rest of Matthew&#8217;s Vim fu, but after the magic offered up elsewhere in this snippet, I&#8217;m more than willing to let this slide.</li>

<li><strong><code>ZZ</code></strong>. Save the file and quit Vim.</li>
</ol>

<h2 id='final_thoughts'>Final Thoughts</h2>

<p>I love Vim. Every time I feel like I&#8217;ve climbed to a certain level of mastery, I glance up and get a glimpse of how much more of the mountain remains to be climbed. (This actually permeates just about every aspect of my career in computer science.) I find that exciting: There is <em>always</em> more to learn.</p>

<p>It&#8217;s incredible that I was able to learn all this from fifty (or so) twitches of Matthew Draper&#8217;s deft fingers. Perhaps it&#8217;s even more incredible that I&#8217;ve devoted a substantially larger number of my own keystrokes to documenting it. I think writing all this helped me understand it better, as well as cementing it in my mind. Hopefully, it will help somebody else along their way to Vim enlightenment.</p>

<p>If you&#8217;re a Vim user, you really ought to check out VimGolf. It&#8217;s a really fun way to hone your skills. I do have a criticism, though.</p>

<p>Currently, you can only see the solutions that are a little bit above your own score. It would be <em>much</em> better if, once you&#8217;ve submitted a solution, you could see <em>all</em> of the other solutions. VimGolf suggests that you submit multiple entries, incrementally improving your score and thereby unlocking higher and higher scores. This is good in theory, but in practice your immediate betters are usually so similar to your entry that you don&#8217;t learn much, if anything. This is especially true for challenges that get a lot of entries&#8212;you might not see anything that&#8217;s even one keystroke better than your score. You end up stuck in a forest of nearly identical trees. Sure, I could just copy the best-scoring entry I have access to&#8212;assuming it&#8217;s better than my own score&#8212;and climb the ladder that way, but that just feels like cheating. I&#8217;d much rather be stuck with my initial score, and then learn from others&#8217; approaches so that I can do better on similar challenges in the future. After all, VimGolf is a game, a fun way to play with Vim and incidentally learn more about the editor. The sense of competition drives you to become a better Vimmer, but ultimately what I want from VimGolf is a better command of Vim that I can use in real-world coding.</p>
  </article>
</div>


      <footer>
        <p>&copy; 2011 Dan Dorman</p>
      </footer>
    </div>
  </body>
</html>
